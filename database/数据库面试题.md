- [1. InnoDB中的事务隔离级别](#1-InnoDB中的事务隔离级别)
- [2. 解释下脏读、不可重复读、幻读](#2-解释下脏读、不可重复读、幻读)
- [3. MyISAM和InnoDB两者之间的区别](#3-MyISAM和InnoDB两者之间的区别)
- [4. MyISAM适合的场景](#4-MyISAM适合的场景)
- [5. InnoDB适合的场景](#5-InnoDB适合的场景)
- [6. 数据库事务的四大特性](#6-数据库事务的四大特性)
- [7. 事务并发访问引起的问题以及如何避免](#7-事务并发访问引起的问题以及如何避免)
- [8. 隐式转换导致索引失效](#8-隐式转换导致索引失效)
- [9. 除了加索引优化查询，还有哪些方法？](#9-除了加索引优化查询，还有哪些方法？)
## 1. InnoDB中的事务隔离级别
SQL标准中的事务四种隔离级别
- 未提交读(Read Uncommitted)：可能出现脏读（可能读取到其他会话中未提交事务修改的数据）、不可重复读、幻读
- 提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)
- 可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读
- 串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞
## 2. 解释下脏读、不可重复读、幻读
- 脏读：指当一个事务正字访问数据，并且对数据进行了修改，而这种数据还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据还没有提交那么另外一个事务读取到的这个数据我们称之为脏数据。依据脏数据所做的操作肯能是不正确的。
- 不可重复读：指在一个事务内，多次读同一数据。在这个事务还没有执行结束，另外一个事务也访问该同一数据，那么在第一个事务中的两次读取数据之间，由于第二个事务的修改第一个事务两次读到的数据可能是不一样的，这样就发生了在一个事物内两次连续读到的数据是不一样的，这种情况被称为是不可重复读。
- 幻读：一个事务先后读取一个范围的记录，但两次读取的纪录数不同，我们称之为幻象读（两次执行同一条 select 语句会出现不同的结果，第二次读会增加一数据行，并没有说这两次执行是在同一个事务中）
## 3. MyISAM和InnoDB两者之间的区别
InnoDB是一个事务型的存储引擎，支持回滚，设计目标是处理大数量数据时提供高性能的服务，它在运行时会在内存中建立缓冲池，用于缓冲数据和索引。
- 优点：
  1. 支持事务处理、ACID事务特性；
  2. 实现了SQL标准的四种隔离级别；
  3. 支持行级锁和外键约束；
  4. 可以利用事务日志进行数据恢复。
  5. 锁级别为行锁，行锁优点是适用于高并发的频繁表修改，高并发是性能优于 MyISAM。缺点是系统消耗较大。
  6. 索引不仅缓存自身，也缓存数据，相比 MyISAM 需要更大的内存。
- 缺点：
  1. 因为它没有保存表的行数，当使用COUNT统计时会扫描全表。

MyISAM 是 MySQL 5.5.5 之前的默认引擎，它的设计目标是快速读取。
- 优点：
  1. 高性能读取;
  2. 因为它保存了表的行数，当使用COUNT统计时不会扫描全表；
- 缺点：
  1. 锁级别为表锁，表锁优点是开销小，加锁快；缺点是锁粒度大，发生锁冲动概率较高，容纳并发能力低，这个引擎适合查询为主的业务。
  2. 此引擎不支持事务，也不支持外键。
  3. INSERT和UPDATE操作需要锁定整个表；
  4. 它存储表的行数，于是COUNT时只需要直接读取已经保存好的值而不需要进行全表扫描。

适用场景
- MyISAM适合：
  1. 做很多count 的计算；
  2. 插入不频繁，查询非常频繁；
  3. 没有事务。

- InnoDB适合：
  1. 可靠性要求比较高，或者要求事务；
  2. 表更新和查询都相当的频繁，并且表锁定的机会比较大的情况
