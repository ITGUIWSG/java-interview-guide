- [1. volatile关键字是否能保证线程安全？](#1-volatile关键字是否能保证线程安全？)
- [2. Java中sleep()和wait()的区别](#2-Java中sleep和wait的区别)
- [3. synchronized和lock的区别？](#3-synchronized和lock的区别？)
- [4. 创建线程有几种不同的方式？你喜欢哪一种？为什么？](#4-创建线程有几种不同的方式？你喜欢哪一种？为什么？)
## 1. volatile关键字是否能保证线程安全？
否，volatile变量自身具有下列特性：
1. 可见性：对一个volatile变量的读，总是能看到(任意线程)对这个volatile变量最后的写入。
2. 禁止进行指令重排序
3. 不保证原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种符合操作不具有原子性。 多线程共享变量的读写是通过主内存进行复制到线程本地内存中和把本地内存中值写入主内存中来实现的。

当写一个volatile变量时，JMM(Java内存模型)会把该线程对应的本地内存中的共享变量值刷新到主内存。

当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从住内存中读取共享变量。
## 2. Java中sleep和wait的区别
- 来自不同的类 : sleep来自Thread类，是Thread类的静态方法。而wait来自于object类。sleep是Thread的静态方法，那个线程调用的了sleep，那个线程就会休眠.
- 持有锁：这一点很重要，sleep是没有释放锁的，使得该线程仍然占用这系统资源，wait方法则会释放锁，使得其他线程可以使用同步控制块或者方法。sleep 不释放系统资源并且有时间限制，需要调用sleep（milliseconds）来指定休眠时间 wait会释放资源，并且进入线程等待池等待，这个时候其他线程可以占用CPU，直到其他线程调用notify/notifyAll唤醒等待池中的线程，然后进入就绪队列等待系统分配资源
- 使用范围： wait，notify，notifyAll只能在synchronized块中或者synchronied控制的方法中调用。而sleep可以在任何地方调用
## 3. synchronized和lock的区别？
- 主要相同点：Lock能完成synchronized所实现的所有功能。
- 主要不同点：Lock有比synchronized更精确的线程予以和更好的性能。
1. synchronized会自动释放锁，但是Lock一定要求程序员手工释放，并且必须在finally从句中释放。
2. synchronized修饰方法时,表示同一个对象在不同的线程中,表现为同步队列,如果实例化不同的对象,那么synchronized就不会出现同步效果了。
## 4. 创建线程有几种不同的方式？你喜欢哪一种？为什么？
三种方式可以用来创建线程：
- 继承Thread类
- 实现Runnable接口
- 应用程序可以使用Executor框架来创建线程池

实现Runnable接口这种方式更受欢迎，因为这不需要继承Thread类。在应用设计中已经继承了别的对象的情况下，这需要多继承（而Java不支持多继承），只能实现接口。

同时，线程池也是非常高效的，很容易实现和使用。
