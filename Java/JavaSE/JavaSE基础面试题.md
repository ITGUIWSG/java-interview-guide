## 1. 一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？
可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。
## 2. Java有没有goto?
java中的保留字，现在没有在java中使用。
## 3. 面向对象和面向过程的区别
### 面向过程
**优点**： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。

**缺点**： 没有面向对象易维护、易复用、易扩展
### 面向对象
**优点**： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护

**缺点**： 性能比面向过程低
## 4. 说说&和&&的区别
&和&&都可以用作逻辑与的运算符，表示逻辑与（and），当运算符两边的表达式的结果都为true时，整个运算结果才为true，否则，只要有一方为false，则结果为false。

&&还具有短路的功能，即如果第一个表达式为false，则不再计算第二个表达式，例如，对于if(str != null && !str.equals(“”))表达式，当str为null时，后面的表达式不会执行，所以不会出现NullPointerException如果将&&改为&，则会抛出NullPointerException异常。If(x==33 & ++y>0) y会增长，If(x==33 && ++y>0)不会增长

&还可以用作位运算符，当&操作符两边的表达式不是boolean类型时，&表示按位与操作，我们通常使用0x0f来与一个整数进行&运算，来获取该整数的最低4个bit位，例如，0x31 & 0x0f的结果为0x01。

备注：这道题先说两者的共同点，再说出&&和&的特殊之处，并列举一些经典的例子来表明自己理解透彻深入、实际经验丰富。
## 5. 在JAVA中如何跳出当前的多重嵌套循环?
在Java中，要想跳出多重循环，可以在外面的循环语句前定义一个标号，然后在里层循环体的代码中使用带有标号的break 语句，即可跳出外层循环。例如，
```java
ok:
	for(int i=0;i<10;i++)	{
		for(int j=0;j<10;j++)		{
			System.out.println(“i=” + i + “,j=” + j);
			if(j == 5) break ok;
		}
	}
```
另外，我个人通常并不使用标号这种方式，而是让外层的循环条件表达式的结果可以受到里层循环体代码的控制，例如，要在二维数组中查找到某个数字。
```java
int arr[][] = {{1,2,3},{4,5,6,7},{9}};
boolean found = false;
for(int i=0;i<arr.length && !found;i++)	{
		for(int j=0;j<arr[i].length;j++){
			System.out.println(“i=” + i + “,j=” + j);
			if(arr[i][j]  == 5) {
				found = true;
				break;
			}
		}
	}
```
## 6. 什么是 JDK 什么是 JRE 什么是 JVM 三者之间的联系与区别?
这几个是Java中很基本很基本的东西，但是我相信一定还有很多人搞不清楚！为什么呢？因为我们大多数时候在使用现成的编译工具以及环境的时候，并没有去考虑这些东西。

JDK: 顾名思义它是给开发者提供的开发工具箱,是给程序开发者用的。它除了包括完整的JRE（Java Runtime Environment），Java运行环境，还包含了其他供开发者使用的工具包。

JRE: 普通用户而只需要安装 JRE（Java Runtime Environment）来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。

JVM： 当我们运行一个程序时，JVM 负责将字节码转换为特定机器代码，JVM 提供了内存管理/垃圾回收和安全机制等。这种独立于硬件和操作系统，正是 java 程序可以一次编写多处执行的原因。

**区别与联系**：

- JDK 用于开发，JRE 用于运行java程序 ；
- JDK 和 JRE 中都包含 JVM ；
- JVM 是 java 编程语言的核心并且具有平台独立性。
## 7. switch语句能否作用在byte上，能否作用在long上，能否作用在String上?
在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。显然，long和String类型都不符合switch的语法规定，并且不能被隐式转换成int类型，所以，它们不能作用于swtich语句中,但是从**Java7开始，exper还可以是String类型**。
## 8. short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
对于short s1 = 1; s1 = s1 + 1; 由于s1+1运算时会自动提升表达式的类型，所以结果是int型，再赋值给short类型s1时，编译器将报告需要强制转换类型的错误。

对于short s1 = 1; s1 += 1;由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
## 9. 用最有效率的方法算出2乘以8等於几?
2 << 3;

因为将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，而位运算cpu直接支持的，效率最高，所以，2乘以8等於几的最效率的方法是2 << 3
## 10. 使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？
使用final关键字修饰一个变量时，是指引用变量不能变，引用变量所指向的对象中的内容还是可以改变的。例如，对于如下语句：
~~~java
 final StringBuffer a=new StringBuffer("immutable");
~~~
执行如下语句将报告编译期错误：
~~~java
a=new StringBuffer("");
~~~
但是，执行如下语句则可以通过编译：
~~~java
a.append(" broken!"); 
~~~

有人在定义方法的参数时，可能想采用如下形式来阻止方法内部修改传进来的参数对象：
~~~java
	public void method(final  StringBuffer  param){}
~~~
实际上，这是办不到的，在该方法内部仍然可以增加如下代码来修改参数对象：
~~~java
		param.append("a");
~~~
