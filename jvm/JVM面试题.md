- [1. 说说你对JVM内存模型的了解，每个区的作用是什么?](#1-说说你对JVM内存模型的了解，每个区的作用是什么?)
- [2. 什么是类的加载](#2-什么是类的加载)
- [3. 类的生命周期](#3-类的生命周期)
- [4. JVM对象分配规则](#4-JVM对象分配规则)
- [5. JVM如何判断对象是否存活](#5-JVM如何判断对象是否存活)
- [6. 介绍一下GC算法有哪些](#6-介绍一下GC算法有哪些)
- [7. JVM有哪些垃圾回收器](#7-JVM有哪些垃圾回收器)
- [8. JVM常用调优命令](#8-JVM常用调优命令)
- [9. JVM常用性能调优参数](#9-JVM常用性能调优参数)
- [10. Java内存模型中堆和栈的区别](#10-Java内存模型中堆和栈的区别)
- [11. JVM中有几种类加载器](#11-JVM中有几种类加载器)
- [12. 什么是双亲委派模型](#12-什么是双亲委派模型)
- [13. 类加载过程](#13-类加载过程)
- [14. 栈溢出的原因](#14-栈溢出的原因)
- [15. 方法区溢出的原因](#15-方法区溢出的原因)
## 1. 说说你对JVM内存模型的了解，每个区的作用是什么?
### 栈区：
栈分为java虚拟机栈和本地方法栈

重点是Java虚拟机栈，它是线程私有的，生命周期与线程相同。

每个方法执行都会创建一个栈帧，用于存放局部变量表，操作栈，动态链接，方法出口等。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程。

通常说的栈就是指局部变量表部分，存放编译期间可知的8种基本数据类型，及对象引用和指令地址。局部变量表是在编译期间完成分配，当进入一个方法时，这个栈中的局部变量分配内存大小是确定的。

会有两种异常StackOverFlowError和 OutOfMemoneyError。当线程请求栈深度大于虚拟机所允许的深度就会抛出StackOverFlowError错误；虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出OutOfMemoneyError。

本地方法栈为虚拟机使用到本地方法服务（native）

### 堆区：

- 堆是被所有线程共享的一块区域，在虚拟机启动时创建，唯一目的存放对象实例。
- 堆被划分成两个不同的区域：新生代（Young）、老年代（Old）。
- 新生代又被划分为三个区域：Eden和两个幸存区（From survivor 和 To survivor）。
- 新生代主要存储新创建的对象和尚未进入老年代的对象。老年代存储经过多次新生代GC(Minor GC）后仍然存活的对象。
- 会有异常OutOfMemoneyError

### 方法区：

- 被所有线程共享的区域，用于存放已被虚拟机加载的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。有时候也称它为永久代（permanment generation）

- 垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载。

- 常量池用于存放编译期生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；运行期间的常量也可以添加进入常量池中，比如string的intern()方法。

### 程序计数器：

- 当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。

- Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个独立的程序计数器，所以它是线程私有的。

- 唯一一块Java虚拟机没有规定任何OutofMemoryError的区块。
## 2. JVM什么情况下会发生栈内存溢出
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。类的加载的最终产品是位于堆区中的Class对象，Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
## 3. 类的生命周期
类的生命周期包括这几个部分，加载、连接、初始化、使用和卸载
- 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
- 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用
- 初始化，为类的静态变量赋予正确的初始值
- 使用，new出对象程序中使用
- 卸载，执行垃圾回收
## 4. JVM对象分配规则
- 对象优先分配在Eden区，如果Eden区没有足够的空间时，虚拟机执行一次Minor GC。
- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。
- 长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，知道达到阀值对象进入老年区。
- 动态判断对象的年龄。如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。
- 空间分配担保。每次进行Minor GC时，JVM会计算Survivor区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次Full GC，如果小于检查HandlePromotionFailure设置，如果true则只进行Monitor GC,如果false则进行Full GC。
## 5. JVM如何判断对象是否存活
判断对象是否存活一般有两种方式：
- 引用计数：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。
- 可达性分析（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的，不可达对象。
## 6. 介绍一下GC算法有哪些
GC最基础的算法有三种：标记 -清除算法、复制算法、标记-压缩算法，我们常用的垃圾回收器一般都采用分代收集算法。
- 标记 -清除算法，“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。
- 复制算法，“复制”（Copying）的收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
- 标记-压缩算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存
- 分代收集算法，“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。
## 7. JVM有哪些垃圾回收器
- Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，可能会产生较长的停顿，只使用一个线程去回收。
- ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。
- Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。
- Parallel Old 收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和“标记－整理”算法
- CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。
- G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征
## 8. JVM常用调优命令
Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo
- jps，JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
- jstat，JVM statistics Monitoring是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
- jmap，JVM Memory Map命令用于生成heap dump文件
- jhat，JVM Heap Analysis Tool命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看
- jstack，用于生成java虚拟机当前时刻的线程快照。
- jinfo，JVM Configuration info 这个命令作用是实时查看和调整虚拟机运行参数。
## 9. JVM常用性能调优参数
- Xss：规定了每个线程虚拟机栈的大小
- Xms：堆的初始值
- Xmx：堆能达到的最大值
## 10. Java内存模型中堆和栈的区别
- 管理方式
  - 栈自动释放，堆需要GC
- 空间大小
  - 栈比堆小
- 碎片相关
  - 栈产生的碎片远小于堆
- 分配方式
  - 栈支持静态和动态分配，而堆仅支持动态分配
- 效率
  - 栈的效率比堆高
## 11. JVM中有几种类加载器
类加载器负责读取 Java 字节代码，并转换成java.lang.Class类的一个实例；有以下几张类加载去：
- 启动类加载器(Bootstrap ClassLoader)：Java应用启动时，加载$JAVA_HOME/lib或 -Xbootclasspath指定的路径中的类文件；
- 扩展类加载器(Extension ClassLoaser)：由sun.misc.Launcher$ExtClassLoader实现，负责加载$JAVA_HOME/lib/ext或java.ext.dirs指定路径的类库；
- 应用程序类加载器(Application ClassLoader)：又称系统类加载器，由sun.misc.Launcher$AppClassLoader实现，是ClassLoader.getSystemClassLoader()的返回值。
- 自定义类加载器需要继承抽象类ClassLoader，实现findClass方法，该方法会在loadClass调用的时候被调用，findClass默认会抛出异常。
  - findClass方法表示根据类名查找类对象
  - loadClass方法表示根据类名进行双亲委托模型进行类加载并返回类对象
  - loadClass方法表示根据类名进行双亲委托模型进行类加载并返回类对象
## 12. 什么是双亲委派模型
- 双亲委托模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委托给父类加载器（父子关系由组合（不是继承）来实现）去完成，每一个层次的类加载器都是如此，
因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需要加载的类）时，
子加载器才会尝试自己去加载。
- 使用双亲委托机制的好处是：
  - 避免同一个类被多次加载；
  - 每个加载器只能加载自己范围内的类；
## 13. 类加载过程
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）

![](https://images.cnblogs.com/cnblogs_com/andy-zhou/806130/o_JVM001.png)

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）。以下陈述的内容都已HotSpot为基准。
## 14. 栈溢出的原因
- 是否有递归调用
- 是否有大量循环或死循环
- 全局变量是否过多
- 数组、List、map数据是否过大
## 15. 方法区溢出的原因
- 动态生成大量Class
- 大量JSP或动态产生JSP文件（JSP第一次运行时需要编译为Java类）
