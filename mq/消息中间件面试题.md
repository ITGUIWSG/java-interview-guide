- [1. 说说RabbitMQ的结构](#1-说说RabbitMQ的结构)
- [2. RabbitMQ交换器种类](#2-RabbitMQ交换器种类)
- [3. RabbitMQ队列与消费者的关系](#3-RabbitMQ队列与消费者的关系)
- [4. 如何保证消息的顺序性](#4-如何保证消息的顺序性)
## 1. 说说RabbitMQ的结构
1. Brocker：消息队列服务器实体。
2. Exchange：消息交换机，用于接收、分配消息。指定消息按什么规则，路由到哪个队列。
3. Queue：消息队列，用于存储生产者的消息。每个消息都会被投入到一个或者多个队列里。
4. Binding Key：绑定关键字，用于把交换器的消息绑定到队列中，它的作用是把exchange和queue按照路由规则binding起来。
5. Routing Key：路由关键字，用于把生产者的数据分配到交换器上。exchange根据这个关键字进行消息投递。
6. Vhost：虚拟主机，一个broker里可以开设多个vhost，用作不用用户的权限分离。
7. Producer：消息生产者，就是投递消息的程序。
8. Consumer：消息消费者，就是接受消息的程序。
9. Channel：信道，消息推送使用的通道。可建立多个channel，每个channel代表一个会话任务。
## 2. RabbitMQ交换器种类
- Direct exchange（直连交换机）：直连型交换机（direct exchange）是根据消息携带的路由键（routing key）将消息投递给对应队列的，步骤如下：
  1. 将一个队列绑定到某个交换机上，同时赋予该绑定一个路由键（routing key）
  2. 当一个携带着路由值为R的消息被发送给直连交换机时，交换机会把它路由给绑定值同样为R的队列。
- Fanout exchange（扇型交换机）：扇型交换机（funout exchange）将消息路由给绑定到它身上的所有队列。不同于直连交换机，路由键在此类型上不启任务作用。如果N个队列绑定到某个扇型交换机上，当有消息发送给此扇型交换机时，交换机会将消息的发送给这所有的N个队列
- Topic exchange（主题交换机）：主题交换机（topic exchanges）中，队列通过路由键绑定到交换机上，然后，交换机根据消息里的路由值，将消息路由给一个或多个绑定队列。
  - 扇型交换机和主题交换机异同：
  1. 对于扇型交换机路由键是没有意义的，只要有消息，它都发送到它绑定的所有队列上
  2. 对于主题交换机，路由规则由路由键决定，只有满足路由键的规则，消息才可以路由到对应的队列上
- Headers exchange（头交换机）：类似主题交换机，但是头交换机使用多个消息属性来代替路由键建立路由规则。通过判断消息头的值能否与指定的绑定相匹配来确立路由规则。 此交换机有个重要参数：”x-match”。
  - 当”x-match”为“any”时，消息头的任意一个值被匹配就可以满足条件
  - 当”x-match”设置为“all”的时候，就需要消息头的所有值都匹配成功
## 3. RabbitMQ队列与消费者的关系
1. 一个队列可以绑定多个消费者；
2. 队列分发消息将以轮询的方式分发，每条消息只会分发给一个订阅的消费者；
3. 消费者收到消息之后默认是自动确认，可以设置手动确认，保证消费者消费了消息。
## 4. 如何保证消息的顺序性
- RabbitMQ
  1. 拆分多个queue，每个queue一个consumer，就是多一些queue而已
  2. 一个queue但是对应一个consumer，然后这个consumer内部用内存队列做排队，然后分发给底层不同的worker来处理
- kafka
  1. 一个topic，一个partition，一个consumer，内部单线程消费，写N个内存queue，然后N个线程分别消费一个内存queue即可
